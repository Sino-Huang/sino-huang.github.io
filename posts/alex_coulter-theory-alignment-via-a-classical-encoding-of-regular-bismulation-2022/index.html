<!DOCTYPE html>
<html dir="auto" lang="en">
<head><meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/>
<meta content="index, follow" name="robots"/>
<title>Alex_coulter Theory Alignment via a Classical Encoding of Regular Bismulation 2022 | Sukai Huang</title>
<meta content="pddl, model comparison" name="keywords"/>
<meta content="[TOC]

Title: Theory Alignment via a Classical Encoding of Regular Bismulation 2022
Author: Alex Coulter et. al.
Publish Year: KEPS 2022
Review Date: Wed, Nov 29, 2023
url: https://icaps22.icaps-conference.org/workshops/KEPS/KEPS-22_paper_7781.pdf

Summary of paper

Motivation

the main question we seek to answer is how we can test if two models align (where the fluents and action implementations may differ), and if not, where that misalignment occurs.

Contribution

the work is built on a foundation of regular bisimulation
found that the proposed alignment was not only viable, with many submissions having “solutions” to the merged model showing where a modelling error occurs, but several cases demonstrated errors with the submitted domains that were subtle and detected only by this added approach.

Some key terms
Bisimulation" name="description"/>
<meta content="Sukai Huang" name="author"/>
<link href="https://sino-huang.github.io/posts/alex_coulter-theory-alignment-via-a-classical-encoding-of-regular-bismulation-2022/" rel="canonical"/>
<meta content="IFgzhtDTVCjONQMwQsBfuf0ZyHdzUR5WFYzbWsf2Gf8" name="google-site-verification"/>
<link as="style" crossorigin="anonymous" href="/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css" integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet"/>
<link href="https://sino-huang.github.io/favicon.ico" rel="icon"/>
<link href="https://sino-huang.github.io/favicon-16x16.png" rel="icon" sizes="16x16" type="image/png"/>
<link href="https://sino-huang.github.io/favicon-32x32.png" rel="icon" sizes="32x32" type="image/png"/>
<link href="https://sino-huang.github.io/apple-touch-icon.png" rel="apple-touch-icon"/>
<link href="https://sino-huang.github.io/safari-pinned-tab.svg" rel="mask-icon"/>
<meta content="#2e2e33" name="theme-color"/>
<meta content="#2e2e33" name="msapplication-TileColor"/>
<link href="https://sino-huang.github.io/posts/alex_coulter-theory-alignment-via-a-classical-encoding-of-regular-bismulation-2022/index.xml" rel="alternate" type="application/rss+xml"/>
<link href="https://sino-huang.github.io/posts/alex_coulter-theory-alignment-via-a-classical-encoding-of-regular-bismulation-2022/" hreflang="en" rel="alternate"/>
<noscript>
<style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
<style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-TTFTV1EWH5"></script>
<script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-TTFTV1EWH5');
        }
      </script><meta content="https://sino-huang.github.io/posts/alex_coulter-theory-alignment-via-a-classical-encoding-of-regular-bismulation-2022/" property="og:url"/>
<meta content="Sukai Huang" property="og:site_name"/>
<meta content="Alex_coulter Theory Alignment via a Classical Encoding of Regular Bismulation 2022" property="og:title"/>
<meta content="[TOC]
Title: Theory Alignment via a Classical Encoding of Regular Bismulation 2022 Author: Alex Coulter et. al. Publish Year: KEPS 2022 Review Date: Wed, Nov 29, 2023 url: https://icaps22.icaps-conference.org/workshops/KEPS/KEPS-22_paper_7781.pdf Summary of paper Motivation the main question we seek to answer is how we can test if two models align (where the fluents and action implementations may differ), and if not, where that misalignment occurs. Contribution the work is built on a foundation of regular bisimulation found that the proposed alignment was not only viable, with many submissions having “solutions” to the merged model showing where a modelling error occurs, but several cases demonstrated errors with the submitted domains that were subtle and detected only by this added approach. Some key terms Bisimulation" property="og:description"/>
<meta content="en" property="og:locale"/>
<meta content="website" property="og:type"/>
<meta content="https://sino-huang.github.io/posts/alex_coulter-theory-alignment-via-a-classical-encoding-of-regular-bismulation-2022/image-assets/cover.png" property="og:image"/>
<meta content="summary_large_image" name="twitter:card"/>
<meta content="https://sino-huang.github.io/posts/alex_coulter-theory-alignment-via-a-classical-encoding-of-regular-bismulation-2022/image-assets/cover.png" name="twitter:image"/>
<meta content="Alex_coulter Theory Alignment via a Classical Encoding of Regular Bismulation 2022" name="twitter:title"/>
<meta content="Sukai's academic blog - storing weekly reports and research paper reviews" name="twitter:description"/>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://sino-huang.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Alex_coulter Theory Alignment via a Classical Encoding of Regular Bismulation 2022",
      "item": "https://sino-huang.github.io/posts/alex_coulter-theory-alignment-via-a-classical-encoding-of-regular-bismulation-2022/"
    }
  ]
}
</script>
</head>
<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<header class="header">
<nav class="nav">
<div class="logo">
<a accesskey="h" href="https://sino-huang.github.io/" title="Sukai Huang (Alt + H)">Sukai Huang</a>
<div class="logo-switches">
<button accesskey="t" id="theme-toggle" title="(Alt + T)">
<svg fill="none" height="18" id="moon" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
</svg>
<svg fill="none" height="18" id="sun" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
<circle cx="12" cy="12" r="5"></circle>
<line x1="12" x2="12" y1="1" y2="3"></line>
<line x1="12" x2="12" y1="21" y2="23"></line>
<line x1="4.22" x2="5.64" y1="4.22" y2="5.64"></line>
<line x1="18.36" x2="19.78" y1="18.36" y2="19.78"></line>
<line x1="1" x2="3" y1="12" y2="12"></line>
<line x1="21" x2="23" y1="12" y2="12"></line>
<line x1="4.22" x2="5.64" y1="19.78" y2="18.36"></line>
<line x1="18.36" x2="19.78" y1="5.64" y2="4.22"></line>
</svg>
</button>
</div>
</div>
<ul id="menu">
<li>
<a href="https://sino-huang.github.io/biography/" title="Biography">
<span>Biography</span>
</a>
</li>
<li>
<a href="https://sino-huang.github.io/archives" title="Archive">
<span>Archive</span>
</a>
</li>
<li>
<a href="https://sino-huang.github.io/tags/" title="Tags">
<span>Tags</span>
</a>
</li>
<li>
<a href="https://sino-huang.github.io/categories/" title="Categories">
<span>Categories</span>
</a>
</li>
<li>
<a accesskey="/" href="https://sino-huang.github.io/search/" title="Search (Alt + /)">
<span>Search</span>
</a>
</li>
</ul>
</nav>
</header>
<main class="main">
<header class="page-header"><div class="breadcrumbs"><a href="https://sino-huang.github.io/">Home</a> » <a href="https://sino-huang.github.io/posts/">Posts</a></div>
<h1>
    Alex_coulter Theory Alignment via a Classical Encoding of Regular Bismulation 2022
    <a aria-label="RSS" href="/posts/alex_coulter-theory-alignment-via-a-classical-encoding-of-regular-bismulation-2022/index.xml" title="RSS">
<svg fill="none" height="23" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M4 11a9 9 0 0 1 9 9"></path>
<path d="M4 4a16 16 0 0 1 16 16"></path>
<circle cx="5" cy="19" r="1"></circle>
</svg>
</a>
</h1>
</header>
<div class="post-content"><p>[TOC]</p>
<ol>
<li>Title: Theory Alignment via a Classical Encoding of Regular Bismulation 2022</li>
<li>Author: Alex Coulter et. al.</li>
<li>Publish Year: KEPS 2022</li>
<li>Review Date: Wed, Nov 29, 2023</li>
<li>url: <a href="https://icaps22.icaps-conference.org/workshops/KEPS/KEPS-22_paper_7781.pdf">https://icaps22.icaps-conference.org/workshops/KEPS/KEPS-22_paper_7781.pdf</a></li>
</ol>
<h2 id="summary-of-paper">Summary of paper<a aria-hidden="true" class="anchor" hidden="" href="#summary-of-paper">#</a></h2>
<p><img alt="image-20231129172526275" loading="lazy" src="/posts/alex_coulter-theory-alignment-via-a-classical-encoding-of-regular-bismulation-2022/image-assets/cover.png"/></p>
<h3 id="motivation">Motivation<a aria-hidden="true" class="anchor" hidden="" href="#motivation">#</a></h3>
<ul>
<li>the main question we seek to answer is how we can test if two models align (where the fluents and action implementations may differ), and if not, where that misalignment occurs.</li>
</ul>
<h3 id="contribution">Contribution<a aria-hidden="true" class="anchor" hidden="" href="#contribution">#</a></h3>
<ul>
<li>the work is built on a foundation of regular bisimulation</li>
<li>found that the proposed alignment was not only viable, with many submissions having “solutions” to the merged model showing where a modelling error occurs, but several cases demonstrated errors with the submitted domains that were subtle and detected only by this added approach.</li>
</ul>
<h3 id="some-key-terms">Some key terms<a aria-hidden="true" class="anchor" hidden="" href="#some-key-terms">#</a></h3>
<p><strong>Bisimulation</strong></p>
<ul>
<li>loosely defined, a bisimulation is a correspondence between two transition system such taht labeled transitions between two systems coincide: if two nodes (one from each system) coincide, then the reachable nodes in  each system also coincide (following the labeled transitions)</li>
<li>regular bisimulation
<ul>
<li>the labels of the transitions are presumed to be the same, as well as the reachable state space (predicates?)</li>
</ul>
</li>
</ul>
<p><strong>Merge</strong></p>
<ul>
<li>we merge them. This merged domain retains the original types, action names/parameters, objects and constants (assumed to be the equivalent in both of the original models)</li>
<li>fluents and initial states are merged</li>
<li>finally, failure actions are introduced that represent a potential misalignment between the two models.
<ul>
<li>as long as one of these failure action can be executed, the two theories do not align (measuring the ‘false negative’)</li>
</ul>
</li>
</ul>
<p><strong>Alignment specification Assumptions</strong></p>
<ul>
<li>types: we assume that the typing for each of the two models are precisely the same. This is required in order to adequately handle the action parameter space.</li>
<li>objects / constants: Similarly, we assume that the objects and constants, including the types they adopt, are precisely the same between the two models. Moreover, we assume that both of the models use these objects in the same way.</li>
<li>Action Names &amp; Parameters: the space of full ground action specification must coincide. Thus, making sure the same action names and :paramaters definition is used in both of the models under consideration.</li>
<li><strong>Initial States</strong> We assume that each model captures the same initial state semantically.
<ul>
<li>meaning, same task</li>
</ul>
</li>
<li>Fluents: We <em>do not</em> assume that the fluents are aligned.
<ul>
<li>meaning: we can have different predicate setting and thus different action precon and effect details</li>
</ul>
</li>
<li>Action Precondition and Effect:
<ul>
<li>we do not assume there to be any syntactic equivalence between the action precondition / effect of the two models.</li>
<li>this allows us to compare widely different encodings of the same real world system.</li>
<li>given that the fluents are not assumed to be coincide, the effective application of the action will be analyzed through the alignment process</li>
</ul>
</li>
</ul>
<p><strong>Encoding</strong></p>
<ul>
<li>every shared action has a pair of “failure actions” introduced that correspond to the situation where the action can be executed in the one model, but not the other.</li>
<li>during the process, rename all of the predicates/fluents throughout both model so that they are unique: we prepend a prefix to every occurrence of a fluent (e.g., adding <u>domain1_</u> or <u>domain2_</u> to the start of every fluent name)
<ul>
<li>failure action can only be executed in one model</li>
</ul>
</li>
</ul>
<p><strong>Failed Goal</strong></p>
<ul>
<li>if solution exists, it means that we can at least achieve some states in the precondition of some actions</li>
<li>the only way to achieve the goal is for one of the fail actions to be executed, if this happens, it means there will be an action that give different semantic effects and eventually leads to contradiction in precondition section.</li>
<li><img alt="image-20231201130304259" loading="lazy" src="/posts/alex_coulter-theory-alignment-via-a-classical-encoding-of-regular-bismulation-2022/image-assets/image-20231201130304259.png"/></li>
</ul>
<p><strong>Error Example</strong></p>
<p><img alt="image-20231201193802959" loading="lazy" src="/posts/alex_coulter-theory-alignment-via-a-classical-encoding-of-regular-bismulation-2022/image-assets/image-20231201193802959.png"/></p>
<p><img alt="image-20231201195846651" loading="lazy" src="/posts/alex_coulter-theory-alignment-via-a-classical-encoding-of-regular-bismulation-2022/image-assets/image-20231201195846651.png"/></p>
<ul>
<li>this is an erroneous action definition as it did not set <code>not (off ?l)</code>. (forgetting to delete a fluent.) The found plan for the merged domain is then <code>(turnon light2)</code> and then <code>(fail_turnon2 light2)</code>.
<ul>
<li>this means the action was allowed to execute in the second domain, but not the first</li>
<li>it is only through the analysis we present here that the misalignment between the two models is detected.</li>
</ul>
</li>
</ul>
<p><strong>Diagnose a misalignment between models</strong></p>
<ul>
<li><em>Failed action precondition</em>. The most common source of error found is an error in precondition of the failed action. Thus, the first step in analyzing a plan is to contrast the precondition of act in both of the models, and see if there is mismatch in what is implemented</li>
<li><em>Previous Action Effect</em>: If the two models capture act similarly, then the next most common issue leading to misalignment is a previous action in the plan. Typically, candidate solutions that lead to a failure are short, and so the space of actions that must be considered is limited.
<ul>
<li>it would be an action that directly influences the failed action act (through its preconditions)</li>
</ul>
</li>
<li><em>Initial State</em>: the most rare source of errors is a misalignment in the initial state implementation.
<ul>
<li>this source of error can be seen as analogous to the “Previous Action Effect” Errors, when one views the initial state as the effects of a single action at the start of a plan.</li>
</ul>
</li>
</ul>
<p><strong>Precondition Satisfaction</strong></p>
<ul>
<li>Applicability, by its very definition, is concerned with precondition satisfaction</li>
</ul>
<p><strong>How planner is involved in this work</strong></p>
<ul>
<li>to decide if they are indeed regular bisimilar</li>
<li>if they are not, a candidate explanation as to why in the form of a sequence of actions
<ul>
<li>if <code>(fail_turnon2 light2)</code> is in the plan, then check the correctness of <code>turnon2</code></li>
</ul>
</li>
</ul>
<h3 id="evaluation">Evaluation<a aria-hidden="true" class="anchor" hidden="" href="#evaluation">#</a></h3>
<ul>
<li>there is an assignment task where the implementation involved devising (1) the fluents for the domain; (2) the preconditions and effects for 4 actions (move, pickup, drop, unlock; (3) the initial and goal states for 3 described problems</li>
</ul>
<p><strong>Other grading indicators</strong></p>
<ul>
<li>other planning oriented functionality included
<ol>
<li>running student domain/problem files to generate plans</li>
<li>validating student-found plans with the reference model</li>
<li>validating reference plans with the student model</li>
<li>align to a model which include the most common error</li>
</ol>
</li>
<li>in the end, we can find the following errors
<ul>
<li>plan-based errors</li>
<li>validation errors (the plan from one model should be executable and valid in the other model)</li>
<li>alignment error (the aligning method in this paper)</li>
</ul>
</li>
</ul>
<h2 id="good-things-about-the-paper-one-paragraph">Good things about the paper (one paragraph)<a aria-hidden="true" class="anchor" hidden="" href="#good-things-about-the-paper-one-paragraph">#</a></h2>
<ul>
<li>There is a rich theory behind what is being analyzed – plans in the merged model effectively provide us with a proof of contradiction to the two models being a regular bismulation ([Milner 1990](Milner, R. 1990. Operational and Algebraic Semantics of Concurrent Processes. In van Leeuwen, J., ed., Handbook of Theoretical Computer Science, Volume B: Formal Models and Semantics, 1201–1242. Elsevier and MIT Press))</li>
</ul>
<h2 id="major-comments">Major comments<a aria-hidden="true" class="anchor" hidden="" href="#major-comments">#</a></h2>
<ul>
<li>They discuss the (mainly qualitative) results in Section 4.</li>
</ul>
</div>
</main>
<footer class="footer">
<span>© 2024 <a href="https://sino-huang.github.io/">Sukai Huang</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &amp;
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
</span>
</footer>
<a accesskey="g" aria-label="go to top" class="top-link" href="#top" id="top-link" title="Go to Top (Alt + G)">
<svg fill="currentColor" viewbox="0 0 12 6" xmlns="http://www.w3.org/2000/svg">
<path d="M12 6H0l6-6z"></path>
</svg>
</a>
<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>
</html>
